<!DOCTYPE html>
<html>
<head>
<title>how_to_use</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* Markdown.css */
/* Authors: Kevin Burke: http://kev.inburke.com/, modified by Evan Wondrasek  */
/* https://bitbucket.org/kevinburke/markdowncss */

body{
    margin: 0 auto;
    font-family: Georgia, Palatino, serif;
    color: #444444;
    line-height: 1;
    max-width: 960px;
    padding: 5px;
}
h1, h2, h3, h4 {
    color: #111111;
    font-weight: 400;
}
h1, h2, h3, h4, h5, p {
    margin-bottom: 16px;
    padding: 0;
}
h1 {
    font-size: 28px;
}
h2 {
    font-size: 22px;
    margin: 20px 0 6px;
}
h3 {
    font-size: 21px;
}
h4 {
    font-size: 18px;
}
h5 {
    font-size: 16px;
}
a {
    color: #0099ff;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
}
a:hover {
    text-decoration: none;
    color: #ff6600;
}
a:visited {
    color: purple;
}
ul, ol {
    padding: 0;
    margin: 0;
}
li {
    line-height: 24px;
    margin-left: 44px;
}
li ul, li ul {
    margin-left: 24px;
}
p, ul, ol {
    font-size: 14px;
    line-height: 20px;
    max-width: 540px;
}
pre {
    padding: 0px 24px;
    max-width: 800px;
    white-space: pre-wrap;
}
code {
    font-family: Consolas, Monaco, Andale Mono, monospace;
    line-height: 1.5;
    font-size: 13px;
}
aside {
    display: block;
    float: right;
    width: 390px;
}
blockquote {
    border-left:.5em solid #eee;
    padding: 0 2em;
    margin-left:0;
    max-width: 476px;
}
blockquote  cite {
    font-size:14px;
    line-height:20px;
    color:#bfbfbf;
}
blockquote cite:before {
    content: '\2014 \00A0';
}

blockquote p {  
    color: #666;
    max-width: 460px;
}
hr {
    width: 540px;
    text-align: left;
    margin: 0 auto 0 0;
    color: #999;
}

button,
input,
select,
textarea {
  font-size: 100%;
  margin: 0;
  vertical-align: baseline;
  *vertical-align: middle;
}
button, input {
  line-height: normal;
  *overflow: visible;
}
button::-moz-focus-inner, input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
button,
input[type="button"],
input[type="reset"],
input[type="submit"] {
  cursor: pointer;
  -webkit-appearance: button;
}
input[type=checkbox], input[type=radio] {
  cursor: pointer;
}
/* override default chrome & firefox settings */
input:not([type="image"]), textarea {
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

input[type="search"] {
  -webkit-appearance: textfield;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
label,
input,
select,
textarea {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 13px;
  font-weight: normal;
  line-height: normal;
  margin-bottom: 18px;
}
input[type=checkbox], input[type=radio] {
  cursor: pointer;
  margin-bottom: 0;
}
input[type=text],
input[type=password],
textarea,
select {
  display: inline-block;
  width: 210px;
  padding: 4px;
  font-size: 13px;
  font-weight: normal;
  line-height: 18px;
  height: 18px;
  color: #808080;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}
select, input[type=file] {
  height: 27px;
  line-height: 27px;
}
textarea {
  height: auto;
}

/* grey out placeholders */
:-moz-placeholder {
  color: #bfbfbf;
}
::-webkit-input-placeholder {
  color: #bfbfbf;
}

input[type=text],
input[type=password],
select,
textarea {
  -webkit-transition: border linear 0.2s, box-shadow linear 0.2s;
  -moz-transition: border linear 0.2s, box-shadow linear 0.2s;
  transition: border linear 0.2s, box-shadow linear 0.2s;
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}
input[type=text]:focus, input[type=password]:focus, textarea:focus {
  outline: none;
  border-color: rgba(82, 168, 236, 0.8);
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
}

/* buttons */
button {
  display: inline-block;
  padding: 4px 14px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 13px;
  line-height: 18px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  background-color: #0064cd;
  background-repeat: repeat-x;
  background-image: -khtml-gradient(linear, left top, left bottom, from(#049cdb), to(#0064cd));
  background-image: -moz-linear-gradient(top, #049cdb, #0064cd);
  background-image: -ms-linear-gradient(top, #049cdb, #0064cd);
  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #049cdb), color-stop(100%, #0064cd));
  background-image: -webkit-linear-gradient(top, #049cdb, #0064cd);
  background-image: -o-linear-gradient(top, #049cdb, #0064cd);
  background-image: linear-gradient(top, #049cdb, #0064cd);
  color: #fff;
  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
  border: 1px solid #004b9a;
  border-bottom-color: #003f81;
  -webkit-transition: 0.1s linear all;
  -moz-transition: 0.1s linear all;
  transition: 0.1s linear all;
  border-color: #0064cd #0064cd #003f81;
  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
}
button:hover {
  color: #fff;
  background-position: 0 -15px;
  text-decoration: none;
}
button:active {
  -webkit-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
  -moz-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
}
button::-moz-focus-inner {
  padding: 0;
  border: 0;
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="sdk-">SDK使用说明</h1>
<h2 id="-">一、设计说明</h2>
<ol>
<li><p>uniservice<br>开机自启动，自动拨号和解析GPS译码数据；管理MCU相关的功能；<br>所以客户的应用只需要在调用相关接口和接收回调消息就可以了，<br>客户程序不需要管理拨号，只需要根据接口和回调消息判断是否拨号成功即可；</p>
</li><li><p>接口说明<br>uni_api.h</p>
<p> enum UNI_API_REG_ITEM {<br> ACC = 0x0001,   // ACC<br> COLLIDE = 0x0002,   // 碰撞<br> ROLLOVER= 0x0004,   // 侧翻<br> DATA_TRANSFER   = 0x0008,   // 数据透传<br> CAN_READ= 0x0010,   // CAN<br> OBD_READ= 0x0020,   // OBD<br> LTE_DIAL_STATE  = 0x0040,   // LTE拨号状态<br> IO_INPUT= 0x0080,   // IO INPUT<br> };</p>
<p> typedef void(<em>UNI_API_CallbackFunc)(int type, const byte</em> pBuf, int length);</p>
<p> /*</p>
<ul>
<li>FullName:    注册消息接收函数和过滤项</li><li>@param [in]: func : 消息接收回调函数, NULL-取消回调</li><li>@param [in]: filter : 过滤项，API_REG_ITEM里各项的异或值</li><li><p>@return:        1-成功 0-失败<br>*/<br>int UNI_API_SetCallback(UNI_API_CallbackFunc func, int filter);</p>
<p>/*</p>
</li><li>FullName:    获取build.prop值</li><li>@param [out]: buf : 保存读到的value</li><li>@param [in]: length : buf的大小</li><li>@param [in]: key : key</li><li><p>@return:    读到的长度<br><em>/<br>int UNI_API_GetProperty(char</em> buf, int length, const char* key);</p>
<p>/*</p>
</li><li>FullName:    获取MCU软件版本号</li><li>@param [out]: buf : 保存版本号字符串</li><li>@param [in]: length : buf的大小</li><li><p>@return:        读到的长度<br><em>/<br>int UNI_API_GetMcuVersion(char</em> buf, int length);</p>
<p>/*</p>
</li><li>FullName:    获取APP版本号</li><li>@param [out]: buf : 保存版本号字符串</li><li>@param [in]: length : buf的大小</li><li><p>@return:        读到的长度<br><em>/<br>int UNI_API_GetAppVersion(char</em> buf, int length);</p>
<p>/*</p>
</li><li>FullName:    获取SN号</li><li>@param [out]: buf : 保存SN号字符串</li><li>@param [in]: length : buf的大小</li><li><p>@return:        读到的长度<br><em>/<br>int UNI_API_GetSN(char</em> buf, int length);</p>
<p>/*</p>
</li><li>FullName:    写入SN号</li><li>@param [in]: sn : SN号字符串</li><li><p>@return:        1-写入成功 0-写入失败<br><em>/<br>int UNI_API_SetSN(const char</em> sn);</p>
<p>/*</p>
</li><li>FullName:    获取ACC状态</li><li><p>@return:        1-ACC ON, 0-ACC OFF, -1-UNKNOWN<br>*/<br>int UNI_API_GetAccStatus();</p>
<p>/*</p>
</li><li>FullName:    获取电池充电状态</li><li><p>@return:        1-正在充电, 0-未充电, 2-已充满<br>*/<br>int UNI_API_GetChargeStatus();</p>
<p>/*</p>
</li><li>FullName:    获取外部电源电压</li><li>@param [out]: buf : 保存外部电源电压字符串</li><li>@param [in]: length : buf的大小</li><li><p>@return:        读到的长度<br><em>/<br>int UNI_API_GetPowerVoltage(char</em> buf, int length);</p>
<p>/*</p>
</li><li>FullName:    获取内置电池电压</li><li>@param [out]: buf : 保存内置电池电压字符串</li><li>@param [in]: length : buf的大小</li><li><p>@return:        读到的长度<br><em>/<br>int UNI_API_GetBatteryVoltage(char</em> buf, int length);</p>
<p>/*</p>
</li><li>FullName:    获取G-sensor值</li><li>@param [out]: buf : 保存G-sensor的XYZ三个值</li><li><p>@return:        1-成功， 0-失败<br>*/<br>int UNI_API_GetGsensor(short buf[3]);</p>
<p>/*</p>
</li><li>FullName:    设置碰撞阀值</li><li>@param [in]: value : 0-4</li><li><p>@return:        1-成功， 0-失败<br>*/<br>int UNI_API_SetCollideThreshold(int value);</p>
<p>/*</p>
</li><li>FullName:    升级MCU程序</li><li>@param [in]: filepath : 升级文件路径</li><li><p>@return:        1-成功， 0-失败<br><em>/<br>int UNI_API_UpdateMcu(const char</em> filepath);</p>
<p>/*</p>
</li><li>FullName:    升级APP</li><li>@param [in]: filepath : 升级文件路径</li><li><p>@return:        1-成功， 0-失败<br><em>/<br>int UNI_API_UpdateApp(const char</em> filepath);</p>
<p>/*</p>
</li><li>FullName:    设置数据透传串口波特率</li><li>@param [in]: id : 串口编号</li><li>@param [in]: baud : 波特率</li><li><p>@return:        1-成功， 0-失败<br>*/<br>int UNI_API_SetDataTransferParam(int id, int baud);</p>
<p>/*</p>
</li><li>FullName:    获取CAN速度</li><li>@param [in]: channel : 通道号</li><li><p>@return:        1-250K， 2-500K<br>*/<br>int UNI_API_GetCanSpeed(int channel);</p>
<p>/*</p>
</li><li>FullName:    设置CAN速度</li><li>@param [in]: channel : 通道号</li><li>@param [in]: value : 1-250K， 2-500K</li><li><p>@return:        1-成功， 0-失败<br>*/<br>int UNI_API_SetCanSpeed(int channel, int value);</p>
<p>/*</p>
</li><li>FullName:    获取输入IO状态</li><li>@param [in]: id : 1-4</li><li><p>@return:        1/0<br>*/<br>int UNI_API_GetIoInput(int id);</p>
<p>/*</p>
</li><li>FullName:    设置输出IO状态</li><li>@param [in]: id : 1-2</li><li>@param [in]: value : 0/1</li><li><p>@return:        1-成功， 0-失败<br>*/<br>int UNI_API_SetIoOutput(int id, int value);</p>
<p>/*</p>
</li><li>FullName:    数据透传</li><li>@param [in]: id : 设备编号</li><li>@param [in]: pBuf : 数据</li><li>@param [in]: length : pBuf的大小</li><li><p>@return:        1-成功， 0-失败<br><em>/<br>int UNI_API_DataTransfer(int id, const byte</em> pBuf, int length);</p>
<p>/*</p>
</li><li>FullName:    写CAN</li><li>@param [in]: buf : 数据,长度必须是14</li><li><p>@return:        1-成功， 0-失败<br>*/<br>int UNI_API_CanWrite(const byte buf[14]);</p>
<p>/*</p>
</li><li>FullName:    写OBD</li><li>@param [in]: pBuf : 数据</li><li>@param [in]: length : pBuf的大小</li><li><p>@return:        1-成功， 0-失败<br><em>/<br>int UNI_API_ObdWrite(const byte</em> pBuf, int length);</p>
<p>/*</p>
</li><li>FullName:    控制LED灯 打开/关闭</li><li>@param [in]: id : 灯编号 1-GPS 2-LTE</li><li>@param [in]: state : 1-打开 0-关闭</li><li><p>@return:        1-成功， 0-失败<br>*/<br>int UNI_API_LedCtrl(int id, int state);</p>
<p>/*</p>
</li><li>FullName:    获取当前拨号状态</li><li>@return:        1-拨号成功， 0-拨号失败或正在拨号<br>*/<br>int UNI_API_GetLteDialState();</li></ul>
</li></ol>
<p>uni_gps.h</p>
<pre><code>typedef enum 
{
GPS_LOCATION= 0x0100,   // GPS Location
GPS_NMEA= 0x0200,   // GPS NMEA
} UNI_CALLBACK_MSG_ID_T;

typedef enum 
{
E_UNI_LOCATION_LAT_LONG_VALID   = 0x0001, /**&lt;  GPS location has valid latitude and longitude.  */
E_UNI_LOCATION_ALTITUDE_VALID   = 0x0002, /**&lt;  GPS location has a valid altitude.  */
E_UNI_LOCATION_SPEED_VALID  = 0x0004, /**&lt;  GPS location has a valid speed.  */
E_UNI_LOCATION_BEARING_VALID= 0x0008, /**&lt;  GPS location has a valid bearing.  */
E_UNI_LOCATION_ACCURACY_VALID   = 0x0010, /**&lt;  GPS location has valid accuracy.  */
} UNI_LOCATION_VALID_FLAG;

typedef struct 
{
UNI_LOCATION_VALID_FLAG flags;  /**&lt;   Contains GPS location flags bits. */
int64_t timestamp;  /**&lt;   Timestamp for the location fix in UTC million-second base.  */
double  latitude;   /**&lt;   Latitude in degrees. */
double  longitude;  /**&lt;   Longitude in degrees. */
double  altitude;   /**&lt;   Altitude in meters above the WGS 84 reference ellipsoid. */
float   speed;  /**&lt;   Speed km/h. */
float   bearing;/**&lt;   Heading in degrees. */
float   accuracy;   /**&lt;   Expected accuracy in meters. */
int mode;        /**&lt;   模式，A=自动，D=差分，E=估测，N=数据无效 */
int satellite_number;   /**&lt;   Indicates the satellite number. */
} UNI_LOCATION_INFO; 


typedef void(*UNI_GPS_CallbackFunc)(int type, const byte* pBuf, int length);

/*
 * FullName:    注册消息接收函数和过滤项
 * @param [in]: func : 消息接收回调函数, NULL-取消回调
 * @param [in]: filter : 过滤项，UNI_CALLBACK_MSG_ID_T 里各项的异或值
 * @return:        1-成功 0-失败
 */
int UNI_GPS_SetCallback(UNI_GPS_CallbackFunc func, int filter);
</code></pre><h2 id="-">二、调用说明</h2>
<ol>
<li><p>注册回调函数<br>VanDevice.cpp<br>注册回调函数可以收到ACC、CAN等相关推送消息</p>
<p> void VanDevice::ApiCallback(int type, const byte* pBuf, int length)<br> {</p>
<pre><code> if (NULL != m_pInstance) {
     m_pInstance-&gt;OnRecvCallback(type, pBuf, length);
 }
</code></pre><p> }</p>
<p> void VanDevice::OnRecvCallback(int type, const byte* pBuf, int length)<br> {</p>
<pre><code> if (ACC == type) {
     SetAccState(pBuf[0]);
 } else if (IO_INPUT == type) {
     SetIoInput(pBuf[0], pBuf[1]);
 } else if (LTE_DIAL_STATE == type) {
     SetDialState(pBuf[0]);
 } else if (COLLIDE == type) {
     SetCollide(pBuf[0]);
 } else if (ROLLOVER == type) {
     SetRollover(pBuf[0]);
 } else if (DATA_TRANSFER == type) {
     if (pBuf[0] &lt;= 2) {
         m_pUart-&gt;OnRecv(pBuf[0], pBuf+1, length-1);
     }
 } else if (CAN_READ == type) {
     m_pCan-&gt;OnRecv(pBuf, length);
 } else if (OBD_READ == type) {
     m_pObd-&gt;OnRecv(pBuf, length);
 }
</code></pre><p> }</p>
<p> void* VanDevice::ThreadFunc()<br> {</p>
<pre><code> int filter = ACC | IO_INPUT | LTE_DIAL_STATE | COLLIDE | ROLLOVER 
             | DATA_TRANSFER | CAN_READ | OBD_READ;
</code></pre><p> UNI_API_SetCallback(ApiCallback, filter);</p>
<pre><code> while (m_bOpen)
 {
     sem_wait(&amp;m_hSem);
 }

 UNI_API_SetCallback(NULL, 0);
 return NULL;
</code></pre><p> }</p>
</li><li><p>注册GPS推送消息<br>VanLocation.cpp</p>
<p> void VanLocation::GpsCallback(int type, const byte<em> pBuf, int length)<br> {<br> if (GPS_LOCATION == type) {<br> UNI_LOCATION_INFO</em> pLocInfo = (UNI_LOCATION_INFO*)pBuf;</p>
<pre><code>     m_pInstance-&gt;SetLocation(pLocInfo);
</code></pre><p> }<br> }</p>
<p> void VanLocation::SetLocation(const UNI_LOCATION_INFO* pLocInfo)<br> {</p>
<pre><code> m_Lock.Lock();
 memcpy(&amp;m_LocInfo, pLocInfo, sizeof(UNI_LOCATION_INFO));
 m_Lock.Unlock();

 sem_post(&amp;m_hSem);
</code></pre><p> }</p>
<p> bool VanLocation::GetLocation(UNI_LOCATION_INFO* pLocInfo)<br> {</p>
<pre><code> if (NULL==pLocInfo || (Utils::GetUpTime()-m_UpdateTime)&gt;3) {
     return false;
 }

 m_Lock.Lock();
 memcpy(pLocInfo, &amp;m_LocInfo, sizeof(UNI_LOCATION_INFO));
 m_Lock.Unlock();

 return true;
</code></pre><p> }</p>
<p> void* VanLocation::ThreadFunc()<br> {<br> UNI_GPS_SetCallback(GpsCallback, GPS_LOCATION);</p>
<pre><code> while (m_bOpen)
 {
     sem_wait(&amp;m_hSem);
     m_UpdateTime = Utils::GetUpTime();

     /*UNI_LOCATION_INFO* pLocInfo = new UNI_LOCATION_INFO;
     GetLocation(pLocInfo);

     printf(&quot;time=%lld, lat=%.6f, lon=%.6f, alt=%.2f, mode=%c, accuracy=%.2f\n&quot;,

         pLocInfo-&gt;timestamp, pLocInfo-&gt;latitude, pLocInfo-&gt;longitude, pLocInfo-&gt;altitude, 

         pLocInfo-&gt;mode, pLocInfo-&gt;accuracy);

     delete pLocInfo;*/
 }

 UNI_GPS_SetCallback(NULL, 0);
 return NULL;
</code></pre><p> }</p>
</li></ol>
<p><strong>注意：不要在回调函数中执行耗时的操作；</strong></p>
<ol>
<li>判断拨号状态<br>根据UNI_API_GetLteDialState();和消息推送中的LTE_DIAL_STATE可以得到是否拨号成功；<br>拨号成功后即可以连网；</li></ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
